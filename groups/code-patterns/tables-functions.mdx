---
title: "Tables & Functions"
description: "Best practices for defining, structuring, and manipulating tables and functions in Luau, emphasizing clarity and performance."
---

## Tables

### Formatting and Spacing

Use consistent formatting for array-like and dictionary-like tables.

> #### Array-like Tables (Lists)
>
> Use a single line for small, simple lists. Use a new line for each element in larger or complex lists.
>
> ```luau
> -- Small lists on a single line
> local Colors = {"Red", "Green", "Blue"}
> 
> -- Large or complex lists, one item per line
> local PlayerNames = {
>     "AlphaPlayer",
>     "BetaTester",
>     "GammaUser",
>     "DeltaDev",
> }
> ```

> #### Dictionary-like Tables (Maps)
>
> Use a new line for each key-value pair.
>
> ```luau
> local PlayerStats = {
>     MaxHealth = 100,
>     WalkSpeed = 16,
>     Attributes = {
> 		Luck = 2,
> 		Strenght = 5,
> 	},
> }
> ```

> ### Table Access
>
> Use dot notation (`.`) for accessing keys that are valid Luau identifiers. Use bracket notation (`[]`) only when the key contains spaces, or is a number.
>
> ```luau
> local PlayerData = {
>     Name = "Galvagni",
>     ["Last Login"] = os.time(),
> } 
> 
> -- CORRECT
> local PlayerName = PlayerData.Name
> local LastLogin = PlayerData["Last Login"]
> 
> -- INCORRECT
> local PlayerName = PlayerData["Name"]
> ```

## Functions

Functions should be small, focused, and follow clear naming conventions.

> ### Single Responsibility Principle (SRP)
>
> A function should only do one thing. If a function is complex, break it down into smaller.

> ### Pure Functions
>
> Prioritize `Pure Functions` functions that, given the same input, will always return the same output, and have no side effects (they do not modify external state or global variables).
>
> ```luau
> -- PURE FUNCTION
> local function CalculateFinalDamage(BaseDamage: number, Multiplier: number): number
>     return BaseDamage * Multiplier
> end
> ```

> ### Function Parameters
>
> Functions should keep their parameter list short and easy to read. When a function requires more than 4â€“5 parameters, readability and maintainability can decrease significantly.
>
> #### Line Break
>
> When a function needs multiple parameters, split them into separate lines for better visual clarity.
>
> ```luau
> local function HasEquippedItem(
> 	Player: Player,
>    	Item: Item,
>    	Amount: number,
>    	Slot: number,
>    	Attributes: Attributes
> ): boolean
> 
>    -- ...
> end
> ```
>
> #### Table Parameter
>
> If the function takes several related parameters, use a table (object-style) instead. This improves flexibility and avoids confusion about parameter order.
>
> ```luau
> type EquippedItemConfig = {
>     Player: Player,
>     Item: Item,
>     Amount: number,
>     Slot: number,
>     Attributes: Attributes
> }
> 
> local function HasEquippedItem(Config: EquippedItemConfig): boolean
>     local Player = Config.Player
>     local Item = Config.Item
>     local Amount = Config.Amount
>     local Slot = Config.Slot
>     local Attributes = Config.Attributes
> 
>     -- ...
> end
> ```

<Note>
  Functions with excessive parameters are harder to understand, test, and refactor. Always prefer readability and clear intent over compactness.
</Note>